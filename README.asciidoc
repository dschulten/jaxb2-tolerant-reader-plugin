= jaxb2-tolerant-reader-plugin image:https://travis-ci.org/dschulten/jaxb2-tolerant-reader-plugin.svg?branch=master["Build Status", link="https://travis-ci.org/dschulten/jaxb2-tolerant-reader-plugin"]
:toc:
:toc-placement: preamble

XJC plugin to restrict marshalled data according to the TolerantReader pattern.


== Motivation
Sometimes you have an extensive system of schema files with lots of classes and attributes, at times so large that developers struggle with the richness of the schema.
Furthermore, the schema might evolve in incompatible ways for reasons which are out of your control.

The client on the other hand uses only a tiny fraction of the types from the schema. As a developer, I do not want to bother with an enormous tree of classes I don't understand and I want no changes to affect my code base which are irrelevant to my client.

The goal of this plugin is to handle this situation by applying ideas of http://martinfowler.com/bliki/TolerantReader.html[TolerantReader] to JAXB. In an attempt to eat the cake and have it, too, I want to generate beans from the schema, but I want to be able to depend only on the data I care about, and most importantly, I still want to avoid the http://www.alwaysagileconsulting.com/articles/application-antipattern-serialisation/[serialization antipattern] of enterprise integration.

I want to use the incoming xml as a _business document_ defined in terms of a schema by creating a Java bean from it, but not by deserializing it as a remote binary object. I want to decouple my Java bean from the evolution of the schema as much as possible, thus at least partially avoiding the http://blog.iancartwright.com/2006/11/dangers-of-serialization.html[dangers of serialization].

Note that schema changes might still require regeneration and recompilation of the client code. The goal is that at least this should be all there is to do, and that I get immediate feedback when the schema change breaks my client, so I can fix the breaking change at the root.

The plugin configuration can also be handed to the service as an executable description of my client expectations.
It could be http://martinfowler.com/articles/consumerDrivenContracts.html[used as a test] by the service to see which client will break upon any given change.

Finally, the plugin annotates the generated beans with the `@Expose` annotation from https://github.com/dschulten/hydra-java/tree/master/hydra-jsonld[hydra-jsonld], if hydra-jsonld is on the classpath.

== Using the Plugin in a Maven Build
To set up the plugin for a maven build, use the maven-jaxb2-plugin. In the maven plugin configuration add the jaxb2-tolerant-reader xjc plugin and make sure you enable xjc extension mode, as shown below. 
The plugin is activated via the -Xtolerant-reader switch.

NOTE: Currently the tolerant-reader-plugin requires a patch to xjc classinfo (xjc-classinfo-patch). The patch is based upon the xjc version 2.2.11 used by the current maven-jaxb2-plugin. A https://github.com/gf-metro/jaxb/pull/30[pull request] has been submitted to gf-metro. In order to introduce the patch, add it as dependency to the maven-jaxb2-plugin as shown below.

Since the tolerant-reader-plugin updates the `Outline` built from the schema, it must run before other plugins such as the jaxb2-basics plugin, so they can pick up the changes introduced by tolerant-reader-plugin. 

The pom.xml of the https://github.com/dschulten/jaxb2-tolerant-reader-plugin/tree/master/tolerant-reader-plugin/src/it/person[it/person test project] uses the tolerant-reader-plugin with jaxb2-basics plugin.

----

<plugin>
  <groupId>org.jvnet.jaxb2.maven2</groupId>
  <artifactId>maven-jaxb2-plugin</artifactId>
  <version>0.13.1</version>
  <dependencies>
    <dependency>
      <groupId>de.escalon.jaxb2</groupId>
      <artifactId>xjc-classinfo-patch</artifactId>
      <version>0.1.0</version>
    </dependency>
  </dependencies>
  <configuration>
    <extension>true</extension>
    <verbose>true</verbose>
  </configuration>
  <executions>
    <execution>
      <id>person</id>
      <goals>
        <goal>generate</goal>
      </goals>
      <configuration>
        <args>
          <arg>-Xtolerant-reader</arg>
        </args>
        <schemaDirectory>${basedir}/src/main/wsdl/example</schemaDirectory>
        <produces>
          <produce>com.example.person/**/*.java</produce>
        </produces>
        <episode>false</episode>
        <specVersion>2.0</specVersion>
        <plugins>
          <plugin>
            <groupId>de.escalon.jaxb2</groupId>
            <artifactId>jaxb2-tolerant-reader</artifactId>
            <version>0.1.0</version>
          </plugin>
        </plugins>
      </configuration>
    </execution>
  </executions>
</plugin>
----

== Configuration: Include Required Data Only
The idea is to require only the Java beans and bean attributes your client really needs and be tolerant about the rest.
For this, you define a binding file with an `include` element on the schema level where you describe beans that should be generated.


=== Example bindings file
The configuration of the tolerant-reader-plugin uses the http://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.5/tutorial/doc/JAXBUsing4.html[standard customization options] of the xml-to-java compiler xjc. 
Below you see an example of an external binding customization file, i.e a _bindings.xjb_ file which you put into your schemadirectory. In the sample binding below we use the extension binding prefix `tr` for the tolerant-reader plugin namespace.

----
<jxb:bindings version="2.1" xmlns:jxb="http://java.sun.com/xml/ns/jaxb" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:tr="http://jaxb2-commons.dev.java.net/tolerant-reader" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
  jxb:extensionBindingPrefixes="xjc tr">
  <jxb:globalBindings>
    <xjc:serializable uid="1" />
  </jxb:globalBindings>

  <jxb:bindings schemaLocation="Person.xsd">
    <tr:include packageRoot="com.example">
      <tr:bean name="Person" properties="name age shippingAddress" />
      <tr:bean name="BaseAddress" properties="addr1 city" />
      <tr:bean name="USAddress" properties="state zip" />
      <!-- bean alias with property alias -->
      <tr:bean name="GlobalAddress" alias="Address" properties="country">
        <tr:alias property="postalCode">postCode</tr:alias>
      </tr:bean>
      <!-- property firstName will be included as-is,
        property lastName will appear as givenName -->
      <tr:bean name="Name" properties="firstName">
        <tr:alias property="lastName">givenName</tr:alias>
      </tr:bean>
    </tr:include>
  </jxb:bindings>
</jxb:bindings>
----

==== include element
Add one include element as customization root.

===== packageRoot attribute (optional)
You may add a `packageRoot` attribute to an `include` element if you have to select beans from specific packages. The package root does not have to be the entire package name, it uses startsWith to match packages. That way you can be tolerant about particular versions of a schema if the schema provider uses version numbers in namespaces.

I.e. if the schema uses a target namespace `com.example.namespace.fun.v5_7`, you can use a packageRoot `com.example.namespace.fun` to select your beans. 

TIP: In situations where the schema uses versioned namespaces, apply https://jaxb.java.net/guide/Customizing_Java_packages.html[custom java packages] to further decouple your beans. If you do this, the original versioned namespace is preserved during marshalling via the package definition in _package-info.java_.

==== bean element
Describes an expected bean. Super classes will be included automatically.

===== name attribute
Simple name of the expected bean. 

===== properties attribute
List of expected bean properties as space-separated strings. You have to define all properties which should be generated. Properties may be defined in super classes.
If an included property has a complex type, the bean for that type will be included automatically.

In cases where you do not simply expect an attribute, but also want to rename it, use an alias element instead.

==== alias element
List of aliased properties to include inside a bean element, can be used in combination with the properties attribute.
The generated property will be renamed to the value of the alias element. Specify the property you want to rename with the property attribute.

===== property attribute
Original property name of an alias element

=== Configuring annotation with hydra-jsonld `@Expose`

Have the following *plugin* dependency in your _pom.xml_.

----
<plugin>
  <groupId>org.jvnet.jaxb2.maven2</groupId>
  <artifactId>maven-jaxb2-plugin</artifactId>
  <version>0.13.1</version>
  <dependencies>
    ...
    <dependency>
      <groupId>de.escalon.hypermedia</groupId>
      <artifactId>hydra-jsonld</artifactId>
      <version>0.3.0</version>
    </dependency>
  </dependencies>
  ...
----
The plugin detects the presence of hydra-jsonld and annotates the beans with `@Expose`. Sample Person:

----
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Person")
@Expose("http://example.com/person/Person")
public class Person {

    @Expose("http://example.com/person/Person#name")
    public Name getName() {
        return name;
    }
}
----
== Plugin Developers

=== Building the Plugin Project
This section is for peoply who do not want to use the plugin, but who want to build the plugin themselves.

Normally it should be sufficient to invoke mvn clean install on the plugin project.

If you run the maven build of the plugin project with embedded maven (e.g. inside Eclipse), make sure you have an environment variable `M2_HOME` pointing to a standalone maven installation which can be picked up by the maven invoker plugin during integration test.

=== Manual execution
As a plugin developer you may want to execute the plugin manually, but you want its output in the same place where maven puts it.

In launch and debug configurations you can execute the plugin via the `com.sun.tools.xjc.Driver` Java main class, with the tolerant-reader-plugin and the xjc-classinfo-patch on the classpath (make sure the xjc-classinfo-patch comes before tolerant-reader-plugin on the classpath in your launch configuration). 

Build the plugin project. This is necessary to create an executable maven test project in _target/it/person_.

Use the _target/it/person_ project as *current working directory* of the launch configuration and pass the following arguments:

    -extension -no-header -d target/generated-sources/xjc -Xtolerant-reader -b src/main/wsdl/example/bindings.xjb src/main/wsdl/example/Person.xsd

=== Running the Sample Project in Eclipse
The sample project in _src/it_ makes use of placeholders for the maven invoker plugin. Therefore it cannot run as-is; you have to import the project created by maven-invoker-plugin in _target/it_. 

* Import the parent project as Maven project
* Execute a maven build on the parent (with standalone maven; or make sure you have a `M2_HOME` environment variable) so that the invoker plugin creates a runnable project in _target/it_.
* Open the parent project
* Open the module tolerant-reader-plugin
* Navigate to _target/it/person_
* Right click the _person_ folder and select "Import as Project"
* Right click the newly imported project and select "Run As - Maven build"

== Acknowledgements
David Tiller, https://www.captechconsulting.com/blogs/make-a-surgical-strike-with-a-custom-xjc-plugin[Make a Surgical Strike with a Custom XJC Plugin] and http://www.captechconsulting.com/blogs/extending-xjc-functionality-with-a-custom-plugin[Extending XJC Functionality With a Custom Plugin]+
Dr. Aleksei Valikov, whose http://stackoverflow.com/questions/32560138/tell-jaxb-binding-compiler-which-elements-to-include[answer on stackoverflow] encouraged me to write this plugin
Nicolas Frï¿½nkel's blog entry https://blog.frankel.ch/customize-your-jaxb-bindings[Customize your JAXB bindings] shows additional ways to customize your JAXB classes, e.g. with base classes and converters.
